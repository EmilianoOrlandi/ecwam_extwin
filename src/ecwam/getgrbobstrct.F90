! (C) Copyright 1989- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

SUBROUTINE GETGRBOBSTRCT(BLK2LOC, NPR, KGRIB_HANDLE)

!****  *GETGRBOBSTRCT* - DETERMINES OBSTRUCTION COEFFICIENTS FROM BINARY INPUT 

! -------------------------------------------------------------------

USE PARKIND_WAVE, ONLY : JWIM, JWRB, JWRU
USE YOWDRVTYPE  , ONLY : WVGRIDLOC, FORCING_FIELDS

USE YOWABORT , ONLY : WAM_ABORT
USE YOWGRIBINFO, ONLY : WVGETGRIDINFO
USE YOWMAP   , ONLY : NGX, NGY, IPER, IRGG, IQGAUSS,                   &
                   &  AMOWEP, AMOSOP, AMOEAP, AMONOP, XDELLA, XDELLO,  &
                   &  NLONRGG
USE YOWMPP   , ONLY : IRANK
USE YOWPARAM , ONLY : NFRE_RED, LL1D
USE YOWSTAT  , ONLY : IPROPAGS, LSUBGRID
USE YOWSPEC  , ONLY : NSTART, NEND
USE YOWTEST  , ONLY : IU06
USE YOWUBUF  , ONLY : OBSLAT, OBSLON, OBSCOR, OBSRLAT, OBSRLON,  &
                    & NPROPAGS, NANG_OBS, KTOIS, KTOOBSTRUCT
USE YOWUNIT  , ONLY : IREADG, IU08
USE YOWWIND  , ONLY : NXFFS_LOC, NXFFE_LOC, NYFFS_LOC, NYFFE_LOC

USE YOWGRIB  , ONLY : IGRIB_GET_VALUE, IGRIB_CLOSE_FILE, IGRIB_RELEASE, &
                    & IGRIB_SET_VALUE, IGRIB_NEW_FROM_FILE, &
                    & JPGRIB_END_OF_FILE, JPKSIZE_T

USE MPL_MODULE, ONLY : MPL_SCATTERV
USE YOMHOOK  , ONLY : LHOOK,   DR_HOOK, JPHOOK

!----------------------------------------------------------------------

IMPLICIT NONE

#include "init_fieldg.intfb.h"
#include "inwgrib.intfb.h"
#include "ktoobs.intfb.h"
#include "wvchkmid.intfb.h"


TYPE(WVGRIDLOC), INTENT(IN) :: BLK2LOC          !! POINTERS FROM LOCAL GRID POINTS TO 2-D MAP
INTEGER(KIND=JWIM), INTENT(IN) :: NPR           !! NUMBER OF SUBDOMAINS (USUALLY THE NUMBER OF PE'S )
INTEGER(KIND=JWIM), INTENT(IN) :: KGRIB_HANDLE  !! GRIB HANDLE CONNECTED TO SUB GRIB BATHY INPUT

INTEGER(KIND=JWIM) :: M, K, IP, IC
INTEGER(KIND=JWIM) :: IREAD, IRET, IERR, IEDITION
INTEGER(KIND=JWIM) :: NGX_SUB, NGY_SUB, IPER_SUB, IRGG_SUB, IQGAUSS_SUB
INTEGER(KIND=JWIM) :: MPLENGTH, KCOUNT
INTEGER(KIND=JWIM), DIMENSION(NPR) :: ICOUNTS
INTEGER(KIND=JWIM), ALLOCATABLE :: ICOMBUF_S(:)
INTEGER(KIND=JWIM), ALLOCATABLE :: ICOMBUF_R(:)
INTEGER(KIND=JWIM), ALLOCATABLE :: IDUM(:)
INTEGER(KIND=JWIM), ALLOCATABLE :: KDUM(:)
INTEGER(KIND=JWIM), ALLOCATABLE, DIMENSION(:) :: NLONRGG_SUB

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

REAL(KIND=JWRB) ::  AMOWEP_SUB, AMOSOP_SUB, AMOEAP_SUB, AMONOP_SUB, XDELLA_SUB, XDELLO_SUB

! INPUT FORCING FIELDS ON THE WAVE MODEL GRID:
TYPE(FORCING_FIELDS) :: FIELDG

LOGICAL :: LLSCANNS_SUB, LLSAMEGRID
LOGICAL :: LLINIALL, LLOCAL

!----------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('GETGRBOBSTRCT',0,ZHOOK_HANDLE)

IREAD = IREADG
LLSAMEGRID = .TRUE.


! OBSTRUCTION COEFFICIENTS
! NOTE: THEIR VALUES WILL BE RESET IN THE FIRST
! CALL TO PROPAGS TO CONTAIN THE OBSTRUCTION TIME THE GROUP
! VELOCITY At THE INTERFACE !!!!!!!!

IF (ALLOCATED(OBSLON)) DEALLOCATE(OBSLON)
ALLOCATE(OBSLON(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))

IF (ALLOCATED(OBSLAT)) DEALLOCATE(OBSLAT)
ALLOCATE(OBSLAT(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))

IF (IPROPAGS == 1) THEN
  IF (ALLOCATED(OBSRLON)) DEALLOCATE(OBSRLON)
  ALLOCATE(OBSRLON(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))
  IF (ALLOCATED(OBSRLAT)) DEALLOCATE(OBSRLAT)
  ALLOCATE(OBSRLAT(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))
ENDIF

IF (IPROPAGS == 2) THEN
  IF (ALLOCATED(OBSCOR)) DEALLOCATE(OBSCOR)
  ALLOCATE(OBSCOR(NSTART(IRANK):NEND(IRANK),NFRE_RED,4))
ENDIF


IF ( LSUBGRID ) THEN

  CALL KTOOBS(IU06)

  ! INWGRIB REQUIRES FIELDG
  CALL FIELDG%ALLOC(NXFFS_LOC, NXFFE_LOC, NYFFS_LOC, NYFFE_LOC, FIELDG)

  LLINIALL=.FALSE.
  LLOCAL=.TRUE.
  CALL INIT_FIELDG(BLK2LOC, LLINIALL, LLOCAL,                           &
 &                 NXFFS_LOC, NXFFE_LOC, NYFFS_LOC, NYFFE_LOC, FIELDG)


  ! BEFORE LOOPING OVER ALL FREQUENCIES, CHECK THAT THE SUBGRID DATA ARE FOR THE SAME GRID
  ! (we will only check the first entry)
  IF (IRANK == IREAD) THEN 

    CALL WVCHKMID(IU06, KGRIB_HANDLE,__FILENAME__)

    CALL WVGETGRIDINFO(IU06, KGRIB_HANDLE, &
 &                     NGX_SUB, NGY_SUB, IPER_SUB, IRGG_SUB, IQGAUSS_SUB, NLONRGG_SUB, LLSCANNS_SUB, &
 &                     AMOWEP_SUB, AMOSOP_SUB, AMOEAP_SUB, AMONOP_SUB, XDELLA_SUB, XDELLO_SUB )

    !! Check that it is the same as input BATHY
    CALL IGRIB_GET_VALUE(KGRIB_HANDLE,'editionNumber', IEDITION, IERR)

    IF ( IEDITION == 1 ) THEN
      !! Until we can use the grib2 template for spectra,
      !! we need to limit what can be compared with the grib2 BATHY
      IF ( NGX_SUB /= NGX .OR. NGY_SUB /= NGY .OR. IPER_SUB .NE. IPER .OR. IQGAUSS_SUB .NE. IQGAUSS ) THEN
        LLSAMEGRID = .FALSE.
      ENDIF
    ELSE
      IF ( NGX_SUB /= NGX .OR. NGY_SUB /= NGY .OR. IPER_SUB .NE. IPER .OR. IQGAUSS_SUB .NE. IQGAUSS .OR. &
 &         AMOWEP_SUB /= AMOWEP .OR. AMOSOP_SUB /= AMOSOP .OR. AMOEAP_SUB /= AMOEAP .OR. &
 &         XDELLA_SUB /= XDELLA .OR. XDELLO_SUB /= XDELLO ) THEN
        LLSAMEGRID = .FALSE.
      ENDIF
    ENDIF

    IF ( LLSAMEGRID ) THEN
      DO K = 1, NGY
        IF (NLONRGG_SUB(MIN(K,NGY_SUB)) /= NLONRGG(K) ) THEN
            LLSAMEGRID = .FALSE.
           EXIT
        ENDIF
      ENDDO
    ENDIF

    IF( .NOT. LLSAMEGRID ) THEN
      WRITE(IU06,*) "GETGRBOBSTRCT : " 
      WRITE(IU06,*) "MEAN AND SUBGRIB BATHYMETRY DO NOT HAVE THE SAME GRID !" 
      WRITE(IU06,*)  NGX, NGY, IPER, IRGG, IQGAUSS
      WRITE(IU06,*)  NGX_SUB, NGY_SUB, IPER_SUB, IRGG_SUB, IQGAUSS_SUB
      DO K = 1, NGY
        WRITE(IU06,*)  K, NLONRGG(K), NLONRGG_SUB(MIN(K,NGY_SUB))
      ENDDO
      WRITE(IU06,*) AMOWEP, AMOSOP, AMOEAP, AMONOP, XDELLA, XDELLO
      WRITE(IU06,*) AMOWEP_SUB, AMOSOP_SUB, AMOEAP_SUB, AMONOP_SUB, XDELLA_SUB, XDELLO_SUB
      CALL FLUSH(IU06)
      CALL WAM_ABORT("Not same grid !",__FILENAME__,__LINE__)
    ENDIF
  ENDIF


  DO M=1,NFRE_RED ! loop over frequencies
  CALL WAM_ABORT("still to do !",__FILENAME__,__LINE__)
    IF (IRET /= JPGRIB_END_OF_FILE) THEN
    ELSE
      CALL WAM_ABORT("end of file reached !",__FILENAME__,__LINE__)
    ENDIF

  ENDDO ! end loop over frequencies

  IF (IRANK == IREAD) THEN 
    CALL IGRIB_CLOSE_FILE(IU08(IPROPAGS))
    CALL IGRIB_RELEASE(KGRIB_HANDLE)
  ENDIF

  CALL FIELDG%DEALLOC()

ELSE

  !! No obstructions. By-pass the reading of the obstruction coefficients
  OBSLON(:,:,:) = 1.0_JWRB
  OBSLAT(:,:,:) = 1.0_JWRB
  IF (IPROPAGS == 1) THEN
    OBSRLON(:,:,:) = 1.0_JWRB
    OBSRLAT(:,:,:) = 1.0_JWRB
  ENDIF
  IF (IPROPAGS == 2) THEN
    OBSCOR(:,:,:) = 1.0_JWRB
  ENDIF

ENDIF

WRITE(IU06,*) '  OBSTRUCTION COEFFICIENTS FROM GRIB INPUT READ IN'
WRITE(IU06,*) ''
CALL FLUSH(IU06)

IF (LHOOK) CALL DR_HOOK('GETGRBOBSTRCT',1,ZHOOK_HANDLE)

END SUBROUTINE GETGRBOBSTRCT
