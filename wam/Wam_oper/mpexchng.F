      SUBROUTINE MPEXCHNG(FL,NSTART,NEND,KLENBOT,KLENTOP)

!****  *MPEXCHNG* - EXHANGES MESSAGE BETWEEN THE PROCESS IRANK 
!****               AND THE PREVIOUS AND NEXT ONE. 

!     J. BIDLOT    ECMWF   MARCH 1996  MESSAGE PASSING

!     PURPOSE.
!     --------
!     EXHANGE MESSAGE BETWEEN ONE PROCESS AND THE PREVIOUS AND NEXT PE
!     USING MESSAGE PASSING PROTOCOL. FOR EACH PROCESS THERE ARE 2 SEND
!     AND 2 RECEIVE TO BE PERFORMED, EXCEPT FOR THE FIRST AND LAST PE
!     WHICH ONLY NEED 1 OF EACH.

!*    INTERFACE.
!     ----------
!     CALL *MPEXCHNG*(FL,NSTART,NEND,KLENTOP,KLENBOT)

!      *FL*        FREQUENCY SPECTRUM
!      *NSTART*    INDEX OF THE FIRST POINT OF THE SUB GRID DOMAIN
!      *NEND*      INDEX OF THE LAST POINT OF THE SUB GRID DOMAIN
!      *KLENTOP*   LENGTH OF THE MESSAGE SENT BY THE NEXT
!                  SUB GRID DOMAIN (IN GRID POINT UNIT)
!      *KLENBOT*   LENGTH OF THE MESSAGE SENT BY THE PREVIOUS
!                  SUB GRID DOMAIN (IN GRID POINT UNIT)

!     METHOD.
!     -------

!     USING NON-BLOCKING SEND, YOU CAN FIRST SEND ALL MESSAGES THEN
!     CLLECT THEM ACCORDINGLY WITH A BLOCKING RECEIVE.

!     NB BY DEFAULT THE MPL_SEND IS NON BLOCKING BUT FOR CONSITANCY WE
!     WILL SET THE APPROPRIATE PARAMETER FOR NON BLOCKING SEND

!     EXTERNALS.
!     ----------
!     MPL PACKAGE :
!         MPL_SEND
!         MPL_RECV
!         MPL_ABORT 

!     REFERENCES.
!     -----------
!     CHAPTER 4 OF
!     USING MPI, PORTABLE PARALLEL PROGRAMMING WITH THE MESSAGE PASSING 
!     INTERFACE. W.CROPP, E LUSK, A SKJELLUM. MIT PRESS 1995 

! -------------------------------------------------------------------

      USE YOWMPP   , ONLY : IRANK    ,NPROC    ,NPREVIOUS,NNEXT    ,
     &            NINF     ,NSUP     ,KTAG
      USE YOWPARAM , ONLY : NANG     ,NFRE
      USE MPL_MODULE

!----------------------------------------------------------------------
!     ALLOCATABLE ARRAYS THAT ARE PASSED AS SUBROUTINE ARGUMENTS

      INTEGER,DIMENSION(NPROC) :: NSTART,NEND,KLENTOP,KLENBOT
      REAL,DIMENSION(NINF-1:NSUP,NANG,NFRE) :: FL

!----------------------------------------------------------------------
 
      REAL,ALLOCATABLE :: ZCOMBUF(:)

!     0.1 FIND THE MAXIMUM LENGTH OF THE MESSAGE BUFFER
!         ---------------------------------------------
      IF(NPROC.LE.1) THEN
        RETURN
      ELSE IF (IRANK.EQ.1) THEN
        NBUFMAX=MAX(KLENBOT(IRANK+1),KLENBOT(IRANK),KLENTOP(IRANK))
      ELSE IF (IRANK.EQ.NPROC) THEN
        NBUFMAX=MAX(KLENTOP(IRANK-1),KLENBOT(IRANK),KLENTOP(IRANK))
      ELSE
        NBUFMAX=MAX(KLENBOT(IRANK+1),KLENBOT(IRANK),KLENTOP(IRANK),
     &              KLENTOP(IRANK-1))
      ENDIF
!     0.2 ALLOCATE THE MESSAGE BUFFER SPACE
!         ---------------------------------
      NBUFMAX=NBUFMAX*NANG*NFRE
      ALLOCATE(ZCOMBUF(NBUFMAX))

!     0.3 FIND INDEX OF THE START OR END POINT OF THE DIFFERENT MESSAGES
!         --------------------------------------------------------------
      IST=NEND(IRANK)-KLENBOT(IRANK+1)+1
      ISB=NSTART(IRANK)-KLENBOT(IRANK)
      IEB=NSTART(IRANK)+KLENTOP(IRANK-1)-1
      IET=NEND(IRANK)+KLENTOP(IRANK)
 
!     1.1.1 SEND TO NEXT PROCESS
!           --------------------
      IF(NNEXT.NE.0) THEN

!       FILL THE SEND BUFFER
        KCOUNT=0
        DO M=1,NFRE
          DO K=1,NANG
            DO IJ=IST,IST+KLENBOT(NNEXT)-1
              KCOUNT=KCOUNT+1
              ZCOMBUF(KCOUNT)=FL(IJ,K,M)
            ENDDO
          ENDDO
        ENDDO

!       SEND THE BUFFER TO NEXT PROCESS
        CALL MPL_SEND(ZCOMBUF(1:KCOUNT),KDEST=NNEXT,KTAG=KTAG,
     &   CDSTRING='MPEXCHNG 1:')
      ENDIF

!     1.2.1 SEND TO PREVIOUS PROCESS
!           -------------------------
      IF(NPREVIOUS.NE.0) THEN

!       FILL THE SEND BUFFER
        KCOUNT=0
        DO M=1,NFRE
          DO K=1,NANG
            DO IJ=NSTART(IRANK),NSTART(IRANK)+KLENTOP(NPREVIOUS)-1
              KCOUNT=KCOUNT+1
              ZCOMBUF(KCOUNT)=FL(IJ,K,M)
            ENDDO
          ENDDO
        ENDDO

!       SEND THE BUFFER TO PREVIOUS PROCESS
        CALL MPL_SEND(ZCOMBUF(1:KCOUNT),KDEST=NPREVIOUS,KTAG=KTAG+1,
     &   CDSTRING='MPEXCHNG 2:')

      ENDIF

!     1.1.2 RECEIVE FROM PREVIOUS PROCESS
!           -----------------------------
      IF(NPREVIOUS.NE.0) THEN

!       RECEIVE THE BUFFER FROM PREVIOUS PROCESS
        KCOUNT=KLENBOT(IRANK)*NANG*NFRE
        CALL MPL_RECV(ZCOMBUF(1:KCOUNT),KSOURCE=NPREVIOUS,KTAG=KTAG,
     &   CDSTRING='MPEXCHNG 1:')

!       DECODE THE RECEIVED BUFFER
        KCOUNT=0
        DO M=1,NFRE
          DO K=1,NANG
            DO ij=ISB,ISB+KLENBOT(IRANK)-1
              KCOUNT=KCOUNT+1
              FL(IJ,K,M)=ZCOMBUF(KCOUNT)
            ENDDO
          ENDDO
        ENDDO

      ENDIF

!     1.1.2 RECEIVE FROM NEXT PROCESS
!           -------------------------
      IF(NNEXT.NE.0) THEN

!       RECEIVE THE BUFFER FROM NEXT PROCESS
        KCOUNT=KLENTOP(IRANK)*NANG*NFRE
        CALL MPL_RECV(ZCOMBUF(1:KCOUNT),KSOURCE=NNEXT,KTAG=KTAG+1,
     &   CDSTRING='MPEXCHNG 2:')

!       DECODE THE RECEIVED BUFFER
        KCOUNT=0
        DO M=1,NFRE
          DO K=1,NANG
            DO IJ=NEND(IRANK)+1,NEND(IRANK)+KLENTOP(IRANK)
              KCOUNT=KCOUNT+1
              FL(IJ,K,M)=ZCOMBUF(KCOUNT)
            ENDDO
          ENDDO
        ENDDO

      ENDIF

      KTAG=KTAG+2

      DEALLOCATE(ZCOMBUF)

      RETURN
      END SUBROUTINE MPEXCHNG 
