      SUBROUTINE MPEXCHNG(FL,NSTART,NEND,
     &                    NTOPE,NTOPEMAX,IJTOPE,NGBTOPE,NTOPELST,
     &                    NFROMPE,NFROMPEMAX,NIJSTART,NGBFROMPE,
     &                    NFROMPELST)


!****  *MPEXCHNG* - EXHANGES MESSAGE BETWEEN THE PROCESS IRANK
!****               AND THE PREVIOUS AND NEXT ONE.

!     J. BIDLOT    ECMWF   MARCH 1996  MESSAGE PASSING

!     PURPOSE.
!     --------
!     EXHANGE MESSAGE BETWEEN ONE PROCESS AND ITS NEIGHBOURS 

!*    INTERFACE.
!     ----------
!     CALL *MPEXCHNG*(FL,NSTART,NEND,
!    &                NTOPE,NTOPEMAX,IJTOPE,NGBTOPE,NTOPELST,
!    &                NFROMPE,NFROMPEMAX,NIJSTART,NGBFROMPE,
!    &                NFROMPELST)

!      *FL*          FREQUENCY SPECTRUM
!      *NSTART*      INDEX OF THE FIRST POINT OF THE SUB GRID DOMAIN
!      *NEND*        INDEX OF THE LAST POINT OF THE SUB GRID DOMAIN
!      *NTOPE*       TOTAL NUMBER OF NEIGHBOURING PE'S TO SEND
!                    INFORMATION TO
!      *NTOPEMAX*    NTOPEMAX FIRST DIMENSION OF IJTOPE
!      *IJTOPE*      POINTS FOR WHICH INFORMATION HAS TO BE SENT TO
!      *NGBTOPE*     TOTAL NUMBER OF NEIGHBOURING PE'S
!      *NTOPELST*    LIST OF NEIGHBOURING PE'S TO SEND TO.
!      *NFROMPE*     TOTAL NUMBER OF NEIGHBOURING PE'S TO RECEIVED
!                    INFROMATION FROM.
!      *NFROMPEMAX*  MAXIMUM OF NFROMPE
!      *NIJSTART*    INDEX OF THE FIRST HALO POINT OBTAINED FROM
!                    NEIGHBOURING PE'S N THE BUFFERS THAT PADS BOTH
!                    SIDE OF THE -D SEA POINT ARRAY OF THE LOCAL PE.
!                    THE OTHER POINTS ARE STORED IN SUCCESSIVE ORDER
!                    FROM THAT IJSTART.
!      *NGBFROMPE*   NUMBER OF NEIGHBOURING PE'S FROM WHICH INFORMATION
!                    IS POTENTIALLY NEEDED.
!      *NFROMPELST*  LIST OF NEIGHBOURING PE'S TO RECEIVE FROM

!     METHOD.
!     -------

!     USING NON-BLOCKING SEND, YOU CAN FIRST SEND ALL MESSAGES THEN
!     COLLECT THEM ACCORDINGLY WITH A BLOCKING RECEIVE.


!     EXTERNALS.
!     ----------
!     MPL PACKAGE :
!         MPL_SEND
!         MPL_RECV
!         MPL_ABORT

!     REFERENCES.
!     -----------
!     CHAPTER 4 OF
!     USING MPI, PORTABLE PARALLEL PROGRAMMING WITH THE MESSAGE PASSING
!     INTERFACE. W.CROPP, E LUSK, A SKJELLUM. MIT PRESS 1995

! -------------------------------------------------------------------

      USE YOWMPP   , ONLY : IRANK    ,NPROC    ,NPREVIOUS,NNEXT    ,
     &            NINF     ,NSUP     ,KTAG
      USE YOWPARAM , ONLY : NANG     ,NFRE
      USE MPL_MODULE
      USE YOMGSTATS, ONLY : LSYNCSTATS

!----------------------------------------------------------------------
!     ALLOCATABLE ARRAYS THAT ARE PASSED AS SUBROUTINE ARGUMENTS

      INTEGER,DIMENSION(NPROC) :: NSTART,NEND
      INTEGER,DIMENSION(NPROC) :: NTOPE
      INTEGER,DIMENSION(NTOPEMAX,NPROC) :: IJTOPE
      INTEGER,DIMENSION(NGBTOPE) :: NTOPELST
      INTEGER,DIMENSION(NPROC) :: NFROMPE,NIJSTART
      INTEGER,DIMENSION(NGBFROMPE) :: NFROMPELST

      REAL,DIMENSION(NINF-1:NSUP,NANG,NFRE) :: FL

!----------------------------------------------------------------------

      INTEGER,DIMENSION(NGBTOPE) :: ISENDREQ,ISENDLEN

      REAL,ALLOCATABLE :: ZCOMBUFS(:,:)
      REAL,ALLOCATABLE :: ZCOMBUFR(:)
      LOGICAL :: LLOK

      IF(NPROC.LE.1) THEN
        RETURN
      ENDIF

      IF (.NOT.LSYNCSTATS) CALL GSTATS(676,0)

      NBUFMAX=MAX(NTOPEMAX,NFROMPEMAX)*NANG*NFRE
      ALLOCATE(ZCOMBUFS(NBUFMAX,NGBTOPE))
      ALLOCATE(ZCOMBUFR(NBUFMAX))


!     PACK SEND BUFFERS FOR  NEIGHBOURING PE's
!     --------------------------
      DO INGB=1,NGBTOPE
        IPROC=NTOPELST(INGB)
!       FILL THE SEND BUFFER
        KCOUNT=0
        DO M=1,NFRE
          DO K=1,NANG
            DO IH=1,NTOPE(IPROC)
              IJ=IJTOPE(IH,IPROC)
              KCOUNT=KCOUNT+1
              ZCOMBUFS(KCOUNT,INGB)=FL(IJ,K,M)
            ENDDO
          ENDDO
        ENDDO
      ISENDLEN(INGB)=KCOUNT
      ENDDO

!       SEND NON BLOCKING THE BUFFERS

      DO INGB=1,NGBTOPE
        IPROC=NTOPELST(INGB)
        KCOUNT=ISENDLEN(INGB)
        CALL MPL_SEND(ZCOMBUFS(1:KCOUNT,INGB),KDEST=IPROC,KTAG=KTAG,
     &   KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=ISENDREQ(INGB),
     &   CDSTRING='MPEXCHNG:')

      ENDDO


!     RECEIVE FROM NEIGHBOURING PE's
!     ------------------------------


      DO INGB=1,NGBFROMPE

!       RECEIVE THE BUFFER FROM PREVIOUS PROCESS
        CALL MPL_RECV(ZCOMBUFR(1:NBUFMAX),KTAG=KTAG,
     &    KRECVTAG=KRTAG,KFROM=KRFROM,CDSTRING='MPEXCHNG:')
        IF(KRTAG.NE.KTAG) CALL MPL_ABORT
     &    ('MPL_RECV ERROR in MPEXCHNG: MISMATCHED TAGS' )

!!! this test may not be necessary but to start with is ok
        LLOK=.FALSE.
        DO KNGB=1,NGBFROMPE
          IF(KRFROM.EQ.NFROMPELST(KNGB)) THEN
            LLOK=.TRUE.
            EXIT
          ENDIF
        ENDDO
        IF(.NOT.LLOK) CALL MPL_ABORT
     &    ('MPL_RECV ERROR in MPEXCHNG: MESSAGE FROM A NON NEIGHBOUR !')
!!!

!       DECODE THE RECEIVED BUFFER
        KCOUNT=0
        DO M=1,NFRE
          DO K=1,NANG
            DO IH=1,NFROMPE(KRFROM)
              IJ=NIJSTART(KRFROM)+IH-1
              KCOUNT=KCOUNT+1
              FL(IJ,K,M)=ZCOMBUFR(KCOUNT)
            ENDDO
          ENDDO
        ENDDO

      ENDDO
! Wait any outstanding sends to complete

      CALL MPL_WAIT(ZCOMBUFS(1:NBUFMAX,1),KREQUEST=ISENDREQ,
     &              CDSTRING='MPEXCHNG:')

      KTAG=KTAG+1

      IF (.NOT.LSYNCSTATS) CALL GSTATS(676,1)

      DEALLOCATE(ZCOMBUFS)
      DEALLOCATE(ZCOMBUFR)

      END SUBROUTINE MPEXCHNG
