SUBROUTINE OUTWSPEC (SPEC, MARSTYPE, CDATE, IFCST) 

!----------------------------------------------------------------------

!**** *OUTWSPEC*  ENCODES SPECTRA AS PARAMETER 251 USING GRIB API
!                 AND WRITES TO FILE OR TO FDB.

!     J. BIDLOT   ECMWF  APRIL 2010 

!*    PURPOSE.
!     --------

!       ENCODES SPECTRA AND WRITES TO FDB OR TO A FILE.

!**   INTERFACE.
!     ----------

!     SUBROUTINE OUTWSPEC (SPEC)

!*     VARIABLE.   TYPE.     PURPOSE.
!      ---------   -------   --------
!      *SPEC*     REAL      LOCAL SPECTRA OF CURRENT PE.

!     METHOD.
!     -------

!           ENCODE SPECTRA PER FREQUENCY AND DIRECTION
!      INTO GRIB AND WRITE TO FDB OR TO A SINGLE FILE.

!     EXTERNALS.
!     ----------

!     REFERENCE.
!     ----------

!       NONE.

!-------------------------------------------------------------------
USE PARKIND_WAVE, ONLY : JWIM, JWRB, JWRU

USE YOWCOUT  , ONLY : NWRTOUTWAM, LWAM_USE_IO_SERV
USE YOWMAP   , ONLY : IXLG     ,KXLT
USE YOWMESPAS, ONLY : LFDBIOOUT
USE YOWMPP   , ONLY : NPRECI   ,IRANK    ,NPROC    ,NINF     ,NSUP
USE YOWPARAM , ONLY : NANG     ,NFRE     ,NGX      ,NGY
USE YOWPCONS , ONLY : ZMISS
USE YOWSTAT  , ONLY : CDATEF   ,CDTPRO   ,NPROMA_WAM,NWFDBREF ,CFDB2DSP ,LFDBOPEN
USE YOWSPEC  , ONLY : NSTART   ,NEND
USE YOWTEST  , ONLY : IU06     ,ITEST
USE YOWTEXT  , ONLY : ICPLEN   ,CPATH
USE MPL_MODULE
USE FDBSUBS_MOD
USE GRIB_API_INTERFACE
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK

!-----------------------------------------------------------------------
      IMPLICIT NONE
#include "wgribencode_model.intfb.h"
#include "abort1.intfb.h"
#include "grstname.intfb.h"
#include "wgribout.intfb.h"

REAL(KIND=JWRB), DIMENSION(NINF-1:NSUP, NANG, NFRE), INTENT(IN) :: SPEC
CHARACTER(LEN=2), INTENT(IN)    :: MARSTYPE
CHARACTER(LEN=14), INTENT(IN)   :: CDATE
INTEGER(KIND=JWIM), INTENT(IN)  :: IFCST


INTEGER(KIND=JWIM) :: IC, IST, ISTEP, IM, IK, J1, ICNT, IP, IR
INTEGER(KIND=JWIM) :: IJ, IX, IY, I, J, K
INTEGER(KIND=JWIM) :: JKGLO, KIJS, KIJL, NPROMA
INTEGER(KIND=JWIM) :: IPARAM, ITABLE
INTEGER(KIND=JWIM) :: IGLOBAL, ILOCAL
INTEGER(KIND=JWIM) :: ITAG, LFILE, IUOUT
INTEGER(KIND=JWIM) :: MAXOUTTASK, NN, IPREV
INTEGER(KIND=JWIM) :: II, NRCV_MSG, NRCV, IRCV, IWRT
INTEGER(KIND=JWIM) :: IGRIB_HANDLE, IGRBHNDL
INTEGER(KIND=JWIM) :: ISIZE, MAXMSGSIZE, MSIZE
INTEGER(KIND=JWIM) :: IERR, KRCOUNT, KRTAG, KFROM
INTEGER(KIND=JPKSIZE_T) :: KBYTES
INTEGER(KIND=JWIM), DIMENSION(1) :: IMSG1
INTEGER(KIND=JWIM), DIMENSION(NPROC) :: IPR, ISENDCOUNTS, IRECVCOUNTS
INTEGER(KIND=JWIM), DIMENSION(NPROC) :: MSGSIZE
INTEGER(KIND=JWIM), DIMENSION(NPROC) :: ISENDREQ
INTEGER(KIND=JWIM), ALLOCATABLE, DIMENSION(:) :: ISENDMSG
INTEGER(KIND=JWIM), ALLOCATABLE, DIMENSION(:) :: ISENDFROM, IRECVFROM
INTEGER(KIND=JWIM), ALLOCATABLE, DIMENSION(:,:) :: IRECVMSG

REAL(KIND=JWRB) :: ZHOOK_HANDLE
REAL(KIND=JWRB) :: FIELD(NGX, NGY)
REAL(KIND=JWRB), ALLOCATABLE, DIMENSION(:) :: ZSENDBUF, ZRECVBUF

CHARACTER(LEN=296) :: OUTFILEN

!-----------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('OUTWSPEC',0,ZHOOK_HANDLE)
      
ILOCAL=0
NN=NFRE*NANG
MAXOUTTASK=MIN(NPROC,NN)

IF (ITEST.GT.1) THEN
  WRITE(IU06,*) '*      THIS IS OUTWSPEC         *'
  CALL FLUSH (IU06)
ENDIF

FIELD(:,:)=ZMISS

! IPR: for a given PE, it gives the PE to which data should be sent
! in order to do the writing to FDB or to file.
IF (LFDBIOOUT) THEN
  IPREV=1
  DO IP=1,MAXOUTTASK
    IF (MOD(IP-1,NWRTOUTWAM) == 0) THEN
            IPR(IP)=IP
            IPREV=IP
    ELSE
            IPR(IP)=IPREV
    ENDIF
  ENDDO
  DO IP=MAXOUTTASK+1,NPROC
    IPR(IP)=0
  ENDDO
ELSE
  IPR(:)=1
ENDIF

! Number of other PE's that will send data to PE IRANK
NRCV_MSG=0
DO IR=1,IRANK-1
 IF (IPR(IR).EQ.IRANK) THEN
   NRCV_MSG=NRCV_MSG+1
 ENDIF
ENDDO
DO IR=IRANK+1,NPROC
  IF (IPR(IR).EQ.IRANK) THEN
    NRCV_MSG=NRCV_MSG+1
  ENDIF
ENDDO

IUOUT=0
IF (.NOT.LFDBIOOUT .AND. IPR(IRANK).EQ.IRANK) THEN
!  output to file should only take place on one PE
   CALL GRSTNAME(CDTPRO,CDATEF,'SGS',ICPLEN,CPATH,OUTFILEN)
   LFILE=LEN_TRIM(OUTFILEN)
   CALL IGRIB_OPEN_FILE(IUOUT,OUTFILEN(1:LFILE),'w')
ENDIF

ALLOCATE(ZSENDBUF(NPROC*(NEND(IRANK)-NSTART(IRANK)+1)))
ALLOCATE(ZRECVBUF(NEND(NPROC)))
ZRECVBUF(:)=0._JWRB

ISTEP=NPROC

DO IC=1,NN,ISTEP

        IST=ISTEP
        IF(IC+ISTEP.GT.NN ) IST=NN-IC+1

!         COLLECT CONTRIBUTIONS ON ALL PE's (or a subset if less spectral fields
!         ---------------------------------- than PE's)
        ICNT = 0
        DO IP=1,NPROC
          IF (IP <= IST) THEN
            IM=(((IC-1)+IP-1)/NANG)+1
            IK=(IC-1)+IP-(IM-1)*NANG

            DO J1=NSTART(IRANK),NEND(IRANK)
              ICNT = ICNT + 1
              ZSENDBUF(ICNT) = SPEC(J1,IK,IM)
            ENDDO
                          
            ISENDCOUNTS(IP) = NEND(IRANK) - NSTART(IRANK) + 1
          ELSE
            ISENDCOUNTS(IP) = 0
          ENDIF

          IF (IRANK <= IST) THEN
            IRECVCOUNTS(IP) = NEND(IP) - NSTART(IP) + 1
          ELSE
            IRECVCOUNTS(IP) = 0 
          ENDIF
        ENDDO

        CALL GSTATS(692,0)
        CALL MPL_ALLTOALLV(ZSENDBUF,ISENDCOUNTS,                        &
     &                    ZRECVBUF,IRECVCOUNTS,                         &
     &                    CDSTRING='OUTWSPEC:')
        CALL GSTATS(692,1)
        IF (ITEST.GT.1) WRITE(IU06,*) 'SUB OUTWSPEC: MPL_ALLTOALLV DONE'


        CALL GSTATS(1496,0)
        NPROMA=NPROMA_WAM
!$OMP     PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO,KIJS,KIJL,IJ,IX,IY)
        DO JKGLO=1,NEND(NPROC),NPROMA
          KIJS=JKGLO
          KIJL=MIN(KIJS+NPROMA-1,NEND(NPROC))
          DO IJ=KIJS,KIJL
            IX = IXLG(IJ,1)
            IY = NGY- KXLT(IJ,1) +1
            FIELD(IX,IY) = ZRECVBUF(IJ)
          ENDDO
        ENDDO
!$OMP     END PARALLEL DO
        CALL GSTATS(1496,1)

!-----------------------------------------------------------------------

!         OUTPUT FROM ALL PE's WHICH CONTAIN A CONTRIBUTION
!         -------------------------------------------------

        IPARAM=251
        ITABLE=140

!         GRIB ENCODING
        MSGSIZE(:)=0
        IF(IRANK.LE.IST) THEN
          IM=(((IC-1)+IRANK-1)/NANG)+1
          IK=(IC-1)+IRANK-(IM-1)*NANG
          CALL WGRIBENCODE_MODEL(IU06, ITEST, NGX, NGY, FIELD,          &
     &                    ITABLE, IPARAM, 0, IK , IM,                   &
     &                    CDATE, IFCST, MARSTYPE,                       &
     &                    IGRIB_HANDLE)

          CALL IGRIB_GET_MESSAGE_SIZE(IGRIB_HANDLE,KBYTES)
          MSGSIZE(IRANK)=(KBYTES+NPRECI-1)/NPRECI
        ENDIF


!         SHARE MESSAGE SIZES WITH OUTPUT PE
        ITAG=IC
        IF (IPR(IRANK).NE.IRANK .AND. IPR(IRANK).NE.0) THEN
          ALLOCATE(ISENDMSG(1))
          ISENDMSG(1)=MSGSIZE(IRANK)
          CALL MPL_SEND(ISENDMSG(1:1),                                  &
     &                 KDEST=IPR(IRANK),KTAG=ITAG,                      &
     &                 KMP_TYPE=JP_NON_BLOCKING_STANDARD,               &
     &                 KREQUEST=ISENDREQ(1),                            &
     &                 KERROR=IERR,CDSTRING='OUTWSPEC: MSG SIZE')
          IF(IERR.LT.0) CALL MPL_ABORT('MPL_SEND ERROR IN OUTWSPEC')
        ENDIF
!         RECEIVE FROM RELEVANT PE's
        DO IR=1,NRCV_MSG
          CALL MPL_RECV(IMSG1,KFROM=KFROM,KTAG=ITAG,                    &
     &                 KOUNT=KRCOUNT,KRECVTAG=KRTAG,KERROR=IERR,        &
     &                 CDSTRING='OUTWSPEC : GRIB MSG')
          IF(IERR.LT.0) CALL MPL_ABORT('MPL_RECV ERROR IN OUTWSPEC ')
          IF(KRTAG.NE.ITAG) CALL MPL_ABORT('MPL_RECV ERROR OUTWSPEC GRIB MSG:  MISMATCHED TAGS' )
          IF(KRCOUNT.NE.1) THEN
            WRITE(0,*) 'SUB OUTWSPEC GRIB MSG: MISMATCHED MSG LENGTH`' 
            WRITE(0,*) 'IRANK, IR, KFROM, KRCOUNT ',IRANK, IR, KFROM, KRCOUNT
            CALL MPL_ABORT('MPL_RECV ERROR OUTWSPEC GRIB MSG:MISMATCHED MSG LENGTH')
          ENDIF
          MSGSIZE(KFROM)=IMSG1(1)
        ENDDO
!         IS THE SEND FINISHED?
        IF (IPR(IRANK).NE.IRANK .AND. IPR(IRANK).NE.0) THEN
          CALL MPL_WAIT(KREQUEST=ISENDREQ(1),CDSTRING='OUTWSPEC: WAIT FOR SEND MSG')
          DEALLOCATE(ISENDMSG)
        ENDIF


!         OUTPUT GRIB DATA
      ITAG=NN+IC
      IF (MSGSIZE(IRANK).NE.0) THEN 
        ALLOCATE(ISENDMSG(MSGSIZE(IRANK)))
        CALL IGRIB_GET_MESSAGE(IGRIB_HANDLE,ISENDMSG)

!         SEND GRIB MESSAGE TO RELEVANT OUTPUT PE (IF IT IS NOT ONE)
        IF (IPR(IRANK).NE.IRANK .AND. IPR(IRANK).NE.0) THEN
          CALL MPL_SEND(ISENDMSG(1:MSGSIZE(IRANK)),                     &
     &                   KDEST=IPR(IRANK),KTAG=ITAG,                    &
     &                   KMP_TYPE=JP_NON_BLOCKING_STANDARD,             &
     &                   KREQUEST=ISENDREQ(1),                          &
     &                   KERROR=IERR,CDSTRING='OUTWSPEC: GRIB MSG')
          IF(IERR.LT.0) CALL MPL_ABORT('MPL_SEND ERROR IN OUTWSPEC')

          ELSE
!             OUTPUT GRIB DATA THAT ARE ALREADY THERE
            CALL WGRIBOUT(IU06, ITEST,                                  &
     &                    LFDBIOOUT, CFDB2DSP, NWFDBREF, LFDBOPEN,      &
     &                    IUOUT,                                        &
     &                    IGRIB_HANDLE,MSGSIZE(IRANK),ISENDMSG(1))

            ILOCAL=ILOCAL+1
            DEALLOCATE(ISENDMSG)

          ENDIF
          CALL IGRIB_RELEASE(IGRIB_HANDLE)
        ENDIF

!         ANYTHING TO RECEIVE ON PE IRANK FROM OTHER PEs ?
        NRCV=0
        MAXMSGSIZE=0
        ALLOCATE(ISENDFROM(NPROC))
        ISENDFROM(1:NPROC)=0
        DO IR=1,IRANK-1
          IF (IPR(IR).EQ.IRANK.AND.MSGSIZE(IR).NE.0) THEN
            NRCV=NRCV+1
            MAXMSGSIZE=MAX(MAXMSGSIZE,MSGSIZE(IR))
            ISENDFROM(NRCV)=IR
          ENDIF
        ENDDO
        DO IR=IRANK+1,NPROC
          IF (IPR(IR).EQ.IRANK.AND.MSGSIZE(IR).NE.0) THEN
            NRCV=NRCV+1
            MAXMSGSIZE=MAX(MAXMSGSIZE,MSGSIZE(IR))
            ISENDFROM(NRCV)=IR
          ENDIF
        ENDDO

        IF(MAXMSGSIZE.GT.0) THEN
          ALLOCATE(IRECVMSG(MAXMSGSIZE,NRCV))
          ALLOCATE(IRECVFROM(NRCV))
!           RECEIVE FROM RELEVANT PE's
          DO IRCV=1,NRCV
            CALL MPL_RECV(IRECVMSG(1:MAXMSGSIZE,IRCV:IRCV),             &
     &                   KFROM=KFROM,KTAG=ITAG,                         &
     &                   KOUNT=KRCOUNT,KRECVTAG=KRTAG,KERROR=IERR,      &
     &                   CDSTRING='OUTWSPEC : GRIB MSG')
          IF(IERR.LT.0) CALL MPL_ABORT('MPL_RECV ERROR IN OUTWSPEC ')
            IF(KRTAG.NE.ITAG) CALL MPL_ABORT('MPL_RECV ERROR OUTWSPEC:MISMATCHED TAGS' )
            IF(KRCOUNT.NE.MSGSIZE(KFROM)) THEN
              WRITE(0,*) 'SUB OUTWSPEC: MISMATCHED MSG LENGTH`' 
              WRITE(0,*) 'IRANK,IRCV,KFROM,KRCOUNT, MSGSIZE(KFROM)= ',IRANK,IRCV,KFROM,KRCOUNT, MSGSIZE(KFROM)
              CALL MPL_ABORT('MPL_RECV ERROR OUTWSPEC:MISMATCHED MSG LENGTH')
            ENDIF
            IRECVFROM(IRCV)=KFROM

          ENDDO
        ENDIF

!         ARE THE SENDS FINISHED?
        IF (MSGSIZE(IRANK).NE.0 .AND.IPR(IRANK).NE.IRANK .AND.IPR(IRANK).NE.0 ) THEN
          CALL MPL_WAIT(KREQUEST=ISENDREQ(1),CDSTRING='OUTWSPEC: WAIT FOR SEND')
          DEALLOCATE(ISENDMSG)
        ENDIF

!         OUTPUT GRIB DATA (IF ANY)
        IF(MAXMSGSIZE.GT.0) THEN
          DO IWRT=1,NRCV
            DO IRCV=1,NRCV
              IF(ISENDFROM(IWRT).EQ.IRECVFROM(IRCV)) EXIT
            ENDDO
            IF(IRCV.LE.0 .OR. IRCV.GT.NRCV) THEN
              WRITE(0,*) 'SUB OUTWSPEC: MISMATCHED ISENDFROM `' 
              DO II=1,NRCV
                WRITE(0,*) 'II, ISENDFROM(II), IRECVFROM(II) = ',II, ISENDFROM(II), IRECVFROM(II)
              ENDDO
              CALL MPL_ABORT('MPL_RECV ERROR OUTWSPEC:MISMATCHED ISENDFROM')
            ENDIF

            MSIZE=MSGSIZE(IRECVFROM(IRCV))

          CALL IGRIB_NEW_FROM_MESSAGE(IGRBHNDL,IRECVMSG(1:MSIZE,IRCV))
          CALL WGRIBOUT(IU06, ITEST,                                    &
     &                   LFDBIOOUT, CFDB2DSP, NWFDBREF, LFDBOPEN,       &
     &                   IUOUT,                                         &
     &                   IGRBHNDL,MSIZE,IRECVMSG(1,IRCV))

            ILOCAL=ILOCAL+1

            CALL IGRIB_RELEASE(IGRBHNDL)
          ENDDO
        ENDIF

        IF(ALLOCATED(IRECVMSG)) DEALLOCATE(IRECVMSG)
        IF(ALLOCATED(ISENDFROM)) DEALLOCATE(ISENDFROM)
        IF(ALLOCATED(IRECVFROM)) DEALLOCATE(IRECVFROM)

ENDDO ! IC

DEALLOCATE(ZSENDBUF)
DEALLOCATE(ZRECVBUF)

!  MAKE SURE EVERYTHING IS FINISHED
CALL MPL_BARRIER(CDSTRING='OUTWSPEC:')

IF(LFDBIOOUT.AND.ILOCAL.GT.0) THEN
  IGLOBAL = NN
  IERR = ISETFIELDCOUNTFDBSUBS(NWFDBREF,IGLOBAL,ILOCAL)
  IF(IERR.NE.0)THEN
    WRITE(IU06,*) ' ------------------------'
    WRITE(IU06,*) ' ERROR setting fdb field count '
    WRITE(IU06,*) ' in routine OUTWSPEC '
    WRITE(IU06,*) ' FDB ERROR CODE IS ',IERR
    WRITE(IU06,*) ' IGLOBAL = ',IGLOBAL
    WRITE(IU06,*) ' ILOCAL = ',ILOCAL
    WRITE(IU06,*) ' ------------------------'
    CALL FLUSH(IU06)
    CALL ABORT1
  ENDIF
ELSEIF (.NOT.LFDBIOOUT .AND. IPR(IRANK).EQ.IRANK) THEN
!   done writing to file
    CALL IGRIB_CLOSE_FILE(IUOUT)
ENDIF

IF (LHOOK) CALL DR_HOOK('OUTWSPEC',1,ZHOOK_HANDLE)

END SUBROUTINE OUTWSPEC
